// Generated by CoffeeScript 1.8.0
var api, auth, definitions, fs, getModelDefinition, js, me, mongo, mongoose, optimizer, path, settings;

path = require('path');

fs = require('fs');

mongoose = require('mongoose');

mongo = require('./mongo');

js = require('./js');

api = require('./api');

auth = require('./auth');

optimizer = require('./optimizer');

settings = exports.settings = {};

definitions = {};

getModelDefinition = exports.getModelDefinition = function(name) {
  return definitions[name];
};

me = module.exports = {
  Schema: mongoose.Schema,
  encrypt: function(str) {
    return auth.encrypt(str);
  },
  getModel: function(name) {
    return mongoose.models[name];
  },
  getSchema: function(name) {
    return mongo.getSchema(name);
  },
  createModel: function(name, schema, validationMessages) {
    var model;
    model = mongo.createModel(name, schema);
    return js.addModel(model, validationMessages);
  },
  loadModels: function(folder) {
    var ext, load;
    ext = settings.modelExtension || '.js';
    load = function(dir) {
      var file, files, _i, _len, _results;
      files = fs.readdirSync(dir);
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _results.push((function(file) {
          var name, obj, schema, validationMessages;
          file = path.join(dir, file);
          if (!fs.statSync(file).isDirectory()) {
            if (path.extname(file) === ext) {
              obj = require(file);
              name = Object.keys(obj)[0];
              schema = obj[name].schema;
              definitions[name] = obj[name];
              validationMessages = obj[name].validationMessages;
              return me.createModel(name, schema, validationMessages);
            }
          } else {
            return load(file);
          }
        })(file));
      }
      return _results;
    };
    return load(folder);
  },
  connect: function(app, connectionString, cb) {
    mongoose.connect(connectionString, {
      server: {
        socketOptions: {
          keepAlive: 1
        }
      }
    });
    mongoose.connection.on('connected', function() {
      console.log('MongoDB connected');
      if (cb != null) {
        return cb(app);
      }
    });
    mongoose.connection.on('disconnected', function() {
      return console.log('MongoDB disconnected');
    });
    return mongoose.connection.on('error', function(err) {
      return console.log('MongoDB returned with error ' + err);
    });
  },
  setup: function(options) {
    settings.modelExtension = options.modelExtension || '.js';
    settings.modelsFolder = options.modelsFolder || null;
    settings.namespace = options.namespace || null;
    settings.connectionString = options.connectionString || null;
    settings.primaryKey = options.primaryKey || '_id';
    settings.mePath = options.mePath || '/js/me.js';
    settings.meOutputPath = options.meOutputPath || null;
    settings.debug = options.debug || true;
    settings.userModel = options.userModel || 'User';
    settings.usernameField = options.usernameField || 'username';
    settings.passwordField = options.passwordField || 'password';
    settings.authPath = options.authPath || '/api/auth';
    settings.sessionKey = options.sessionKey || 'me';
    settings.powerField = options.powerField || 'power';
    settings.defaultPower = options.defaultPower || 0;
    settings.optimize = options.optimize || null;
    this.loadModels(settings.modelsFolder);
    return this;
  },
  init: function(app, cb) {
    app.use(auth.middleware);
    app.use(api.middleware);
    js.bind(app);
    api.bind(app);
    auth.bind(app);
    if (settings.optimize != null) {
      optimizer.optimize(settings.optimize);
    }
    if (settings.connectionString != null) {
      return this.connect(app, settings.connectionString, cb);
    }
  }
};
