define [], () ->
	#to use this, make sure Ember-Data and jQuery are already available
	me = 
		keys: (obj) ->
			if !Object.keys
	            func = (obj) ->
	                hasOwnProperty = Object.prototype.hasOwnProperty
	                if typeof obj != 'object' && (typeof obj != 'function' || obj == null)
	                    throw new TypeError('Object.keys called on non-object');
	                    return

	                result = []
	                result.push prop for prop of obj when hasOwnProperty.call obj, prop
	                return result
	            return func obj
	        else
	            return Object.keys(obj)
		isEmptyString: (str) ->
	    	if !str? then return true
	    	if !str.substring then return true
	    	if str.length == 0 then return true
	    	return false
		restoreRegex: (str) ->
	    	lastSlash = str.lastIndexOf '/'
	    	pattern = str
	    	if lastSlash != 0
	    		flags = str.substr lastSlash + 1
	    		pattern = str.substr 0, lastSlash + 1
	    	pattern = pattern.substr 1, pattern.length - 2
	    	return new RegExp pattern, flags
		version: '{{version}}'
		models: '{{models}}'
		validators:
			required: (value) ->
				return if (value == null || value == undefined || value == '') then false else true
			match: (value, parameters) ->
				regex = me.restoreRegex parameters[0]
				return null != value && if '' != value then regex.test value else true
		attach: (App, names) ->
			thiz = @
			#for object property
			App.JsonTransform = DS.Transform.extend
				serialize: (value) ->
					return value
				deserialize: (value) ->
					return value

			for name in names
				App[name] = DS.Model.extend @models[name].model
				App[name].reopen
					errors: {}
					modelName: name
					validate: (fields) ->
						@set 'errors', {}
						flag = true
						validations = me.models[@modelName].validations
						for path in me.keys validations
							if fields? && fields.indexOf(path) < 0 then continue
							options = validations[path]
							for option in options
								type = option.type
								message = option.message
								parameters = option.parameters
								validator = thiz.validators[type]
								result = validator @get(path), parameters
								if !result then @set 'errors.' + path, message
								flag = flag && result
						return flag


				
				App[name + 'Adapter'] = DS.RESTAdapter.extend @models[name].adapter
				App[name + 'Serializer'] = DS.RESTSerializer.extend @models[name].serializer
			return
		auth:
			signup: (user) ->
				url = '{{url_signup}}'
				data = JSON.stringify
					user: user.toJSON()
				return new Ember.RSVP.Promise (resolve, reject) ->
					$.ajax
						type: 'POST'
						contentType: 'application/json; charset=utf-8'
						url: url
						data: data
						dataType: 'json'
					.done (data) ->
						resolve data
					.fail (data) ->
						reject data.responseText
			login: (user) ->
				url = '{{url_login}}'
				json = if user.toJSON? then user.toJSON() else user 
				data = JSON.stringify
					user: json
				return new Ember.RSVP.Promise (resolve, reject) ->
					$.ajax
						type: 'POST'
						contentType: 'application/json; charset=utf-8'
						url: url
						data: data
						dataType: 'json'
					.done (data) ->
						resolve data
					.fail (data) ->
						reject data.responseText
			logout: ->
				url = '{{url_logout}}'
				return new Ember.RSVP.Promise (resolve, reject) ->
					$.get(url).done ->
						resolve {}
					.fail ->
						resolve {}

			power: (point) ->
				url = '{{url_power}}' + '/' + point
				return new Ember.RSVP.Promise (resolve, reject) ->
					$.get(url).done (data) ->
						resolve data
					.fail (errors) ->
						reject errors

			check: ->
				url = '{{url_check}}'
				return new Ember.RSVP.Promise (resolve, reject) ->
					$.get(url).done (data) ->
						resolve data
					.fail ->
						resolve null
	return me